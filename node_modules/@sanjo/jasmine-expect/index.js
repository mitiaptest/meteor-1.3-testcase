var util = require('util');
var jRequire = require('jasmine-core/lib/jasmine-core/jasmine');

function ExpectationFailed(message, result) {
  Error.captureStackTrace(this, this.constructor);
  this.name = this.constructor.name;
  this.message = message;
  this.result = result;
}

util.inherits(ExpectationFailed, Error);

module.exports.ExpectationFailed = ExpectationFailed;

module.exports.createJ$ = function () {
  return jRequire.core(jRequire);
}

module.exports.createEnv = function (j$) {
  if (typeof j$ === 'undefined') {
    j$ = module.exports.createJ$();
  }

  j$.Expectation.addCoreMatchers(j$.matchers);

  function addExpectationResult(passed, result, isError) {
    if (!passed) {
      if (isError) {
        throw new Error(result);
      } else {
        throw new ExpectationFailed(result.message);
      }
    }
  }

  var env = {
    customEqualityTesters: [],
    addCustomEqualityTester: function(tester) {
      env.customEqualityTesters.push(tester);
    },
    customMatchers: {},
    addMatchers: function (matchersToAdd) {
      for (var matcherName in matchersToAdd) {
        env.customMatchers[matcherName] = matchersToAdd[matcherName];
      }
    },
    expect: function (actual) {
      return j$.Expectation.Factory({
        util: j$.matchersUtil,
        customEqualityTesters: env.customEqualityTesters,
        customMatchers: env.customMatchers,
        actual: actual,
        addExpectationResult: addExpectationResult
      });
    },
    any: function (clazz) {
      return j$.any(clazz);
    },
    anything: function () {
      return j$.anything();
    },
    objectContaining: function (sample) {
      return j$.objectContaining(sample);
    },
    stringMatching: function (expected) {
      return j$.stringMatching(expected);
    },
    arrayContaining: function(sample) {
      return j$.arrayContaining(sample);
    },
  };

  return env;
}
